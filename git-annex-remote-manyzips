#!/usr/bin/env python

import inspect
import os
import zipfile
import sys
from datetime import datetime
from pathlib import Path
from subprocess import CompletedProcess, run
from shlex import split
from typing import BinaryIO, List
from zipfile import ZIP_DEFLATED, ZIP_LZMA, ZIP_STORED
from zipfile import ZipFile, ZipInfo

from annexremote import Master, ProtocolError, RemoteError, SpecialRemote
from overrides import overrides


LOGFOLDER = Path("./logs/")


class UnsupportedCompression(RemoteError):
    pass


def log_stuff(log_path: Path, lines: List[str]):
    log_path.parent.mkdir(exist_ok=True)
    with open(log_path, "a") as stdout_file:
        stdout_file.write(f"{datetime.now()}\n")
        stdout_file.write(f"{inspect.stack()[2].function}->")
        stdout_file.write(f"{inspect.stack()[1].function}\n")
        stdout_file.write("\n".join(lines))


def _mkdir(directory: Path):
    try:
        directory.mkdir(parents=True, exist_ok=True)
    except OSError as e:
        raise RemoteError(f"Failed to write to {str(directory)!r}")


def copyfileobj(
    fsrc: BinaryIO,
    fdst: BinaryIO,
    length: int = 128 * 1024,
    callback: Optional[Callable[[int], None]] = None,
):
    """
    Copy data while passing the progress through a callback every length bytes.

    shutil.copyfileobj reimplementation with: 
    - a bigger default buffer length; 
    - and a callback to track copying progress.
    Copy data from file-like obj fsrc to file-like obj fdst.
    """
    if callback is None:
        callback = lambda x: None
    # Localize variable access to minimize overhead.
    fsrc_read = fsrc.read
    fdst_write = fdst.write
    streamed_bytes = 0
    while buf := fsrc_read(length):
        streamed_bytes += len(buf)
        callback(streamed_bytes)
        fdst_write(buf)


class ManyZips(SpecialRemote):

    def __init__(self, annex: Master):
        super().__init__(annex)
        self.configs = {
            "address_length": "1 for 16 .zips, 2 for 256, and 3 for 4096.",
            "directory": "Folder to store data.",
            "compression": "Either 'store' for no compression or 'lzma' for .xz compression."
        }

    @property
    def address_length(self) -> int:
        address_length = self.annex.getconfig("address_length")
        address_length = int(address_length) if address_length != "" else 1
        if not 0 < address_length < 3:
            raise RemoteError("address_length value should be greater than zero and smaller than 3.")
        return address_length

    @property
    def compression(self) -> int:
        compression = self.annex.getconfig("compression")
        if not compression
            self.annex.setconfig("compression", "store")
        elif compression == "store"
            compression = ZIP_STORED
        elif compression == "lzma":
            compression = ZIP_LZMA
        elif compression == "deflated":
            compression = ZIP_DEFLATED
        else:
            msg = f"Compression type {compression!r} is not available.\n"
            msg += "Try using 'store', 'lzma', or 'deflated'."
            raise UnsupportedCompression(msg)
        return compression

    @property
    def directory(self) -> Path:
        directory = self.annex.getconfig("directory")
        if not directory:
            raise RemoteError("You need to set directory=")
        directory = Path(directory).resolve()
        return directory

    @overrides
    def initremote(self):
        self.info = {
            "address_length": self.address_length,
            "compression" self.compression,
            "directory": self.directory,
        }
        _mkdir(self.directory)

    @overrides
    def prepare(self):
        self.info = {
            "address_length": self.address_length,
            "compression" self.compression,
            "directory": self.directory,
        }
        if not self.directory.is_dir():
            raise RemoteError(f"{str(self.directory)!r} not found.")

    @overrides
    def transfer_store(self, key: str, filename: str):
        """

        e.g.:
        filename=".git/annex/objects/qW/pV/SHA256E-s148273064--5880ac1cd05eee90db251c027771b4c9f0a55b7c8b2813c95eff59eef465ebd3.wav/SHA256E-s148273064--5880ac1cd05eee90db251c027771b4c9f0a55b7c8b2813c95eff59eef465ebd3.wav"
        """
        if self.checkpresent(key):
            return
        zip_path = self._get_zip_path(key)
        with ZipFile(zip_path, 'w', compression=self.compression, allowZip64=True) as myzip:
            zinfo = ZipInfo.from_file(
                filename, arcname=key, strict_timestamps=myzip._strict_timestamps
            )
            zinfo.compress_type = myzip.compression
            with open(filename, "rb") as src, myzip.open(zinfo, 'w') as dest:
                copyfileobj(src, dest, callback=self.annex.progress)
        if not self.checkpresent(key):
            raise RemoteError("Unknown error while storing the key.")

    @overrides
    def transfer_retrieve(self, key: str, filename: str):
        if not self.checkpresent(key):
            raise RemoteError("Key not present in this remote.")
        mount_point = self._get_mount_point(key)
        tar_path = self._get_tar_path(key)

        # TODO: copy to a tempfile then rename
        copy2(str(mount_point / key), filename)

    @overrides
    def checkpresent(self, key: str) -> bool:
        mount_point = self._get_mount_point(key)
        tar_path = self._get_tar_path(key)
        if tar_path.is_file():
            if not mount_point.is_dir():
                ratarmount(tar_path, mount_point)
            file_path = mount_point / key
            if file_path.is_file():
                # umount(mount_point) #
                return True
        return False

    @overrides
    def remove(self, key: str):
        if not self.checkpresent(key):
            return 
        tar_path = self._get_tar_path(key)
        mount_point = self._get_mount_point(key)
        delete_from_tar(tar_path, key)  # O(n)
        if self.checkpresent(key):
            raise RemoteError("Could not remove.")

    def _get_address(self, key: str) -> str:
        # "SHA256E-s148273064--5880ac1cd05eee9...eef465ebd3.wav"
        parts = key.split("-")
        # ["SHA256E", "s148273064", "5880ac1cd05eee9...eef465ebd3.wav"
        address = parts[-1][:self.address_length]
        # "588"
        return address

    def _get_zip_path(self, key: str) -> Path:
        zip_path_and_stem = self.directory / self._get_address(key)
        return zip_path_and_stem.with_suffix(".zip")
 
    @overrides
    def getavailability(self) -> str:
        return "local"


def main():
    output = sys.stdout
    sys.stdout = sys.stderr

    master = Master(output)
    remote = ManyZips(master)
    master.LinkRemote(remote)
    master.Listen()


if __name__ == "__main__":
    main()
